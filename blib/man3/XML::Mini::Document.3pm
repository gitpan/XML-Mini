.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Mini::Document 3"
.TH XML::Mini::Document 3 "2006-11-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
XML::Mini::Document \- Perl implementation of the XML::Mini Document API.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use XML::Mini::Document;
.Ve
.PP
.Vb 1
\&        use Data::Dumper;
.Ve
.PP
.Vb 1
\&        ###### PARSING XML #######
.Ve
.PP
.Vb 2
\&        # create a new object
\&        my $xmlDoc = XML::Mini::Document->new();
.Ve
.PP
.Vb 2
\&        # init the doc from an XML string
\&        $xmlDoc->parse($XMLString);
.Ve
.PP
.Vb 3
\&        # You may use the toHash() method to automatically
\&        # convert the XML into a hash reference
\&        my $xmlHash = $xmlDoc->toHash();
.Ve
.PP
.Vb 1
\&        print Dumper($xmlHash);
.Ve
.PP
.Vb 1
\&        # You can also manipulate the elements like directly, like this:
.Ve
.PP
.Vb 3
\&        # Fetch the ROOT element for the document
\&        # (an instance of XML::Mini::Element)
\&        my $xmlRoot = $xmlDoc->getRoot();
.Ve
.PP
.Vb 3
\&        # play with the element and its children
\&        # ...
\&        my $topLevelChildren = $xmlRoot->getAllChildren();
.Ve
.PP
.Vb 4
\&        foreach my $childElement (@{$topLevelChildren})
\&        {
\&                # ...
\&        }
.Ve
.PP
.Vb 1
\&        ###### CREATING XML #######
.Ve
.PP
.Vb 1
\&        # Create a new document from scratch
.Ve
.PP
.Vb 1
\&        my $newDoc = XML::Mini::Document->new();
.Ve
.PP
.Vb 10
\&        # This can be done easily by using a hash:
\&        my $h = {       
\&         'spy'  => {
\&                'id'    => '007',
\&                'type'  => 'SuperSpy',
\&                'name'  => 'James Bond',
\&                'email' => 'mi5@london.uk',
\&                'address'       => 'Wherever he is needed most',
\&                },
\&        };
.Ve
.PP
.Vb 1
\&        $newDoc->fromHash($h);
.Ve
.PP
.Vb 2
\&        # Or new XML can also be created by manipulating 
\&        #elements directly:
.Ve
.PP
.Vb 1
\&        my $newDocRoot = $newDoc->getRoot();
.Ve
.PP
.Vb 4
\&        # create the <? xml ?> header
\&        my $xmlHeader = $newDocRoot->header('xml');
\&        # add the version 
\&        $xmlHeader->attribute('version', '1.0');
.Ve
.PP
.Vb 1
\&        my $person = $newDocRoot->createChild('person');
.Ve
.PP
.Vb 3
\&        my $name = $person->createChild('name');
\&        $name->createChild('first')->text('John');
\&        $name->createChild('last')->text('Doe');
.Ve
.PP
.Vb 3
\&        my $eyes = $person->createChild('eyes');
\&        $eyes->attribute('color', 'blue');
\&        $eyes->attribute('number', 2);
.Ve
.PP
.Vb 2
\&        # output the document
\&        print $newDoc->toString();
.Ve
.PP
This example would output :
.PP
.Vb 12
\& <?xml version="1.0"?>
\&  <person>
\&   <name>
\&    <first>
\&     John
\&    </first>
\&    <last>
\&     Doe
\&    </last>
\&  </name>
\&  <eyes color="blue" number="2" />
\&  </person>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The XML::Mini::Document class is the programmer's handle to XML::Mini functionality.
.PP
A XML::Mini::Document instance is created in every program that uses XML::Mini.
With the XML::Mini::Document object, you can access the root XML::Mini::Element, 
find/fetch/create elements and read in or output \s-1XML\s0 strings.
.Sh "new [\s-1XMLSTRING\s0]"
.IX Subsection "new [XMLSTRING]"
Creates a new instance of XML::Mini::Document, optionally calling
fromString with the passed \s-1XMLSTRING\s0
.Sh "getRoot"
.IX Subsection "getRoot"
Returns a reference the this document's root element
(an instance of XML::Mini::Element)
.Sh "setRoot \s-1NEWROOT\s0"
.IX Subsection "setRoot NEWROOT"
setRoot \s-1NEWROOT\s0
Set the document root to the \s-1NEWROOT\s0 XML::Mini::Element object.
.Sh "isElement \s-1ELEMENT\s0"
.IX Subsection "isElement ELEMENT"
Returns a true value if \s-1ELEMENT\s0 is an instance of XML::Mini::Element,
false otherwise.
.Sh "isNode \s-1NODE\s0"
.IX Subsection "isNode NODE"
Returns a true value if \s-1NODE\s0 is an instance of XML::MiniNode,
false otherwise.
.Sh "createElement \s-1NAME\s0 [\s-1VALUE\s0]"
.IX Subsection "createElement NAME [VALUE]"
Creates a new XML::Mini::Element with name \s-1NAME\s0.
.PP
This element is an orphan (has no assigned parent)
and will be lost unless it is appended (\fIXML::Mini::Element::appendChild()\fR)
to an element at some point.
.PP
If the optional \s-1VALUE\s0 (string or numeric) parameter is passed,
the new element's text/numeric content will be set using \s-1VALUE\s0.
Returns a reference to the newly created element.
.Sh "getElement \s-1NAME\s0 [\s-1POSITON\s0]"
.IX Subsection "getElement NAME [POSITON]"
Searches the document for an element with name \s-1NAME\s0.
.PP
Returns a reference to the first XML::Mini::Element with name \s-1NAME\s0,
if found, \s-1NULL\s0 otherwise.
.PP
\&\s-1NOTE:\s0 The search is performed like this, returning the first 
element that matches:
.PP
.Vb 4
\& - Check the Root Element's immediate children (in order) for a match.
\& - Ask each immediate child (in order) to XML::Mini::Element::getElement()
\&  (each child will then proceed similarly, checking all it's immediate
\&   children in order and then asking them to getElement())
.Ve
.PP
If a numeric \s-1POSITION\s0 parameter is passed, \fIgetElement()\fR will return only 
the POSITIONth element of name \s-1NAME\s0 (starting at 1).  Thus, on document
.PP
.Vb 12
\&  <?xml version="1.0"?>
\&  <people>
\&   <person>
\&    bob
\&   </person>
\&   <person>
\&    jane
\&   </person>
\&   <person>
\&    ralph
\&   </person>
\&  </people>
.Ve
.PP
$people\->getElement('person') will return the element containing the text node
\&'bob', while \f(CW$people\fR\->getElement('person', 3) will return the element containing the 
text 'ralph'.
.Sh "getElementByPath \s-1PATH\s0 [\s-1POSITIONARRAY\s0]"
.IX Subsection "getElementByPath PATH [POSITIONARRAY]"
Attempts to return a reference to the (first) element at \s-1PATH\s0
where \s-1PATH\s0 is the path in the structure from the root element to
the requested element.
.PP
For example, in the document represented by:
.PP
.Vb 16
\&         <partRateRequest>
\&          <vendor>
\&           <accessid user="myusername" password="mypassword" />
\&          </vendor>
\&          <partList>
\&           <partNum>
\&            DA42
\&           </partNum>
\&           <partNum>
\&            D99983FFF
\&           </partNum>
\&           <partNum>
\&            ss-839uent
\&           </partNum>
\&          </partList>
\&         </partRateRequest>
.Ve
.PP
.Vb 1
\&        $accessid = $xmlDocument->getElementByPath('partRateRequest/vendor/accessid');
.Ve
.PP
Will return what you expect (the accessid element with attributes user = \*(L"myusername\*(R"
and password = \*(L"mypassword\*(R").
.PP
\&\s-1BUT\s0 be careful:
.PP
.Vb 1
\&        my $accessid = $xmlDocument->getElementByPath('partRateRequest/partList/partNum');
.Ve
.PP
will return the partNum element with the value \*(L"\s-1DA42\s0\*(R".  To access other partNum elements you
must either use the \s-1POSITIONSARRAY\s0 or the \fIgetAllChildren()\fR method on the partRateRequest element.
.PP
\&\s-1POSITIONSARRAY\s0 functions like the \s-1POSITION\s0 parameter to \fIgetElement()\fR, but instead of specifying the
position of a single element, you must indicate the position of all elements in the path.  Therefore, to
get the third part number element, you would use
.PP
.Vb 1
\&        my $thirdPart = $xmlDocument->getElementByPath('partRateRequest/partList/partNum', 1, 1, 3);
.Ve
.PP
The additional 1,1,3 parameters indicate that you wish to retrieve the 1st partRateRequest element in 
the document, the 1st partList child of partRateRequest and the 3rd partNum child of the partList element
(in this instance, the partNum element that contains 'ss\-839uent').
.PP
Returns the XML::Mini::Element reference if found, \s-1NULL\s0 otherwise.
.Sh "parse \s-1SOURCE\s0"
.IX Subsection "parse SOURCE"
Initialise the XML::Mini::Document (and its root XML::Mini::Element) using the
\&\s-1XML\s0 from file \s-1SOURCE\s0.
.PP
\&\s-1SOURCE\s0 may be a string containing your \s-1XML\s0 document.
.PP
In addition to parsing strings, possible SOURCEs are:
.PP
.Vb 2
\&        # a file location string 
\&        $miniXMLDoc->parse('/path/to/file.xml');
.Ve
.PP
.Vb 3
\&        # an open file handle
\&        open(INFILE, '/path/to/file.xml');
\&        $miniXMLDoc->parse(*INFILE);
.Ve
.PP
.Vb 4
\&        # an open FileHandle object
\&        my $fhObj = FileHandle->new();
\&        $fhObj->open('/path/to/file.xml');
\&        $miniXML->parse($fhObj);
.Ve
.PP
In all cases where \s-1SOURCE\s0 is a file or file handle, XML::Mini takes care of slurping the
contents and closing the handle.
.Sh "fromHash \s-1HASHREF\s0 [\s-1OPTIONS\s0]"
.IX Subsection "fromHash HASHREF [OPTIONS]"
Parses a \*(L"hash representation\*(R" of your \s-1XML\s0 structure.  For each key => value pair within the
hash ref, XML::Mini will create an element of name 'key' :
.PP
.Vb 1
\&        - with the text contents set to 'value' if 'value' is a string
.Ve
.PP
.Vb 1
\&        - for each element of 'value' if value is an ARRAY REFERENCE
.Ve
.PP
.Vb 1
\&        - with suitable children for each subkey => subvalue if 'value' is a HASH REFERENCE.
.Ve
.PP
For instance, if \fIfromHash()\fR is passed a simple hash ref like:
.PP
.Vb 1
\&    my $h = {
.Ve
.PP
.Vb 8
\&         'spy'  => {
\&                'id'    => '007',
\&                'type'  => 'SuperSpy',
\&                'name'  => 'James Bond',
\&                'email' => 'mi5@london.uk',
\&                'address'       => 'Wherever he is needed most',
\&        },
\&   };
.Ve
.PP
then :
.PP
.Vb 2
\&  $xmlDoc->fromHash($h);
\&  print $xmlDoc->toString();
.Ve
.PP
will output 
.PP
.Vb 7
\& <spy>
\&  <email> mi5@london.uk </email>
\&  <name> James Bond </name>
\&  <address> Wherever he is needed most </address>
\&  <type> SuperSpy </type>
\&  <id> 007 </id>
\& </spy>
.Ve
.PP
The optional \s-1OPTIONS\s0 parameter may be used to specify which keys to use as attributes (instead of 
creating subelements).  For example, calling
.PP
.Vb 7
\& my $options = { 
\&                        'attributes'    => {
\&                                        'spy'   => 'id',
\&                                        'email' => 'type',
\&                                        'friend' => ['name', 'age'],
\&                                }
\&                };
.Ve
.PP
.Vb 1
\& my $h = {
.Ve
.PP
.Vb 7
\&         'spy'  => {
\&                'id'    => '007',
\&                'type'  => 'SuperSpy',
\&                'name'  => 'James Bond',
\&                'email' => {
\&                                'type'          => 'private',
\&                                '-content'      => 'mi5@london.uk',
.Ve
.PP
.Vb 5
\&                        },
\&                'address' => {
\&                                'type'  => 'residential',
\&                                '-content' => 'Wherever he is needed most',
\&                        },
.Ve
.PP
.Vb 6
\&                'friend' => [
\&                                        {
\&                                                'name'  => 'claudia',
\&                                                'age'   => 25,
\&                                                'type'  => 'close',
\&                                        },
.Ve
.PP
.Vb 5
\&                                        {
\&                                                'name'  => 'monneypenny',
\&                                                'age'   => '40something',
\&                                                'type'  => 'tease',
\&                                        },
.Ve
.PP
.Vb 6
\&                                        {
\&                                                'name'  => 'Q',
\&                                                'age'   => '10E4',
\&                                                'type'  => 'pain',
\&                                        }
\&                                ],
.Ve
.PP
.Vb 2
\&        },
\&   };
.Ve
.PP
.Vb 2
\&  $xmlDoc->fromHash($h, $options);
\&  print $xmlDoc->toString();
.Ve
.PP
will output something like:
.PP
.Vb 18
\& <spy id="007">
\&  <name> James Bond </name>
\&  <email type="private"> mi5@london.uk </email>
\&  <address>
\&   <type> residential </type>
\&   Wherever he is needed most
\&  </address>
\&  <type> SuperSpy </type>
\&  <friend age="25" name="claudia">
\&   <type> close </type>
\&  </friend>
\&  <friend age="40something" name="monneypenny">
\&   <type> tease </type>
\&  </friend>
\&  <friend age="10E4" name="Q">
\&   <type> pain </type>
\&  </friend>
\& </spy>
.Ve
.PP
As demonstrated above, you can use the optional href to specify tags for which attributes (instead of elements) should be 
created and you may nest hash and array refs to create complex structures.
.PP
\&\s-1NOTE:\s0 Whenever a hash references is used you lose the sequence in which the elements are placed \- only the array references (which create
a list of identically named elements) can preserve their order.
.PP
See \s-1ALSO:\s0 the documentation for the related \fItoHash()\fR method.
.PP
Still \s-1TODO:\s0 Create some better docs for this!  For the moment you can take a peek within the test suite of the source distribution.
.Sh "fromString \s-1XMLSTRING\s0"
.IX Subsection "fromString XMLSTRING"
Initialise the XML::Mini::Document (and it's root XML::Mini::Element) using the 
\&\s-1XML\s0 string \s-1XMLSTRING\s0.
.PP
Returns the number of immediate children the root XML::Mini::Element now
has.
.Sh "fromFile \s-1FILENAME\s0"
.IX Subsection "fromFile FILENAME"
Initialise the XML::Mini::Document (and it's root XML::Mini::Element) using the
\&\s-1XML\s0 from file \s-1FILNAME\s0.
.PP
Returns the number of immediate children the root XML::Mini::Element now
has.
.Sh "toString [\s-1DEPTH\s0]"
.IX Subsection "toString [DEPTH]"
Converts this XML::Mini::Document object to a string and returns it.
.PP
The optional \s-1DEPTH\s0 may be passed to set the space offset for the
first element.
.PP
If the optional \s-1DEPTH\s0 is set to \f(CW$XML::Mini::NoWhiteSpaces\fR
no \en or whitespaces will be inserted in the xml string
(ie it will all be on a single line with no spaces between the tags.
.PP
Returns a string of \s-1XML\s0 representing the document.
.Sh "toFile \s-1FILENAME\s0 [\s-1SAFE\s0]"
.IX Subsection "toFile FILENAME [SAFE]"
Stringify and save the \s-1XML\s0 document to file \s-1FILENAME\s0
.PP
If \s-1SAFE\s0 flag is passed and is a true value, toFile will do some extra checking, refusing to open the file
if the filename matches m|/\e.\e./| or m|#;`\e*| or if \s-1FILENAME\s0 points to a softlink.  In addition, if \s-1SAFE\s0
is '\s-1NOOVERWRITE\s0', toFile will fail if the \s-1FILENAME\s0 already exists.
.Sh "toHash"
.IX Subsection "toHash"
Transform the \s-1XML\s0 structure internally represented within the object 
(created manually or parsed from a file or string) into a \s-1HASH\s0 reference and returns the href.
.PP
For instance, if this \s-1XML\s0 is \fIparse()\fRd:
.PP
<people>
.PP
.Vb 6
\& <person id="007">                                   
\&  <email> mi5@london.uk </email>
\&  <name> James Bond </name>
\&  <address> Wherever he is needed most </address>
\&  <type> SuperSpy </type>
\& </person>
.Ve
.PP
.Vb 6
\& <person id="006" number="6">
\&  <comment> I am not a man, I am a free number </comment>
\&  <name> Number 6 </name>
\&  <email type="private"> prisoner@aol.com </email>
\&  <address> 6 Prison Island Road, Prison Island, Somewhere </address>
\& </person>
.Ve
.PP
</people>
.PP
The hash reference returned will look like this (as output by Data::Dumper):
.PP
.Vb 1
\& 'people' => {
.Ve
.PP
.Vb 21
\&      'person' => [
\&                    {
\&                      'email' => 'mi5@london.uk',
\&                      'name' => 'James Bond',
\&                      'type' => 'SuperSpy',
\&                      'address' => 'Wherever he is needed most',
\&                      'id' => '007'
\&                    },
\&                    {
\&                      'email' => {
\&                                   'type' => 'private',
\&                                   '-content' => 'prisoner@aol.com'
\&                                 },
\&                      'comment' => 'I am not a man, I am a free number',
\&                      'number' => '6',
\&                      'name' => 'Number 6',
\&                      'address' => '6 Prison Island Road, Prison Island, Somewhere',
\&                      'id' => '006'
\&                    }
\&                  ]
\&    }
.Ve
.Sh "getValue"
.IX Subsection "getValue"
Utility function, call the root XML::Mini::Element's \fIgetValue()\fR
.Sh "dump"
.IX Subsection "dump"
Debugging aid, dump returns a nicely formatted dump of the current structure of the
XML::Mini::Document object.
.SH "CAVEATS"
.IX Header "CAVEATS"
It is impossible to parse \*(L"cross\-nested\*(R" tags using regular expressions (i.e. sequences of the form
<a><b><a>...</a></b></a>).  However, if you have the Text::Balanced module installed (it is installed 
by default with Perl 5.8), such sequences will be handled flawlessly.
.PP
Even if you do not have the Text::Balanced module available, it is still possible to generate this type
of \s-1XML\s0 \- the problem only appears when parsing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2003 Patrick Deegan, Psychogenic Inc.
.PP
Programs that use this code are bound to the terms and conditions of the \s-1GNU\s0 \s-1GPL\s0 (see the \s-1LICENSE\s0 file). 
If you wish to include these modules in non-GPL code, you need prior written authorisation 
from the authors.
.PP
\&\s-1LICENSE\s0
.PP
.Vb 3
\&    XML::Mini::Document module, part of the XML::Mini XML parser/generator package.
\&    Copyright (C) 2002-2003 Patrick Deegan
\&    All rights reserved
.Ve
.PP
.Vb 4
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of the GNU General Public License as published by
\&    the Free Software Foundation; either version 2 of the License, or
\&    (at your option) any later version.
.Ve
.PP
.Vb 4
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\&    GNU General Public License for more details.
.Ve
.PP
.Vb 3
\&    You should have received a copy of the GNU General Public License
\&    along with this program; if not, write to the Free Software
\&    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
.Ve
.PP
Official XML::Mini site: http://minixml.psychogenic.com
.PP
Contact page for author available at http://www.psychogenic.com/
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::Mini, XML::Mini::Element
.PP
http://minixml.psychogenic.com
